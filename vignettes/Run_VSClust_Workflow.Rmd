---
title: "Run_VSClust_workflow"
output: html_document
date: '2022-03-23'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is an example script to run the full clustering analysis. The same can be done by running the Shiny app (e.g. via docker or on http://computproteomics.bmb.sdu.dk) or the command line script available through bioconda or directly from the code repository https://bitbucket.com/veitveit/vsclust.

## Installation and packages

Use the general library command for installation. The full functionality can be obtained by additionally installing the following packages


```{r}
library(vsclust)
require(yaml)
require(shiny)
require(clusterProfiler)
require(matrixStats)
```

## Initialization



Here, we define the different parameters for the example data set. In the command-line version of vsclust (runVSClust.R), they can be given via yaml file.

TODO: explain them, using the same text as in the help for the function?

```{r}
#### Input parameters, only read when now parameter file was provided #####
# All principal parameters for running VSClust can be defined as in the shiny app at computproteomics.bmb.sdu.dk/Apps/VSClust
Experiment <- "ProtExample" ## name of study
NumReps <- 3###886 ## Number of replicates per
NumCond <- 4###12 ## Number of different experimental conditions (e.g. time points)
isPaired <- F ## Paired or unpaired statistical tests
cores <- 4#4 # Number of cores to use ## 1 is for windows

PreSetNumClustVSClust <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
PreSetNumClustStand <- 0 # If 0, then automatically take the one from Minimum Centroid Distance


maxClust <- 10 ## max. number of clusters when estimating the number of clusters
```

## Statistics

As next, we load the data and carry out statistical testing of all conditions version the first based on the LIMMA moderated t-test.

This will give us false discovery rates for the differentially regulated features and most importantly, their expected individual variances, to be used in the variance-sensitive clustering. These variances can also be uploaded separately via a column containnig them as individual standard deviations.

We also will create a PCA plot to assess variability and control whether the samples have been loaded correctly. 


```{r}

dat <- read.csv(system.file("extdata/ProtExample.csv",package="vsclust"),row.names=1,header=T)    
dat <- dat[rownames(dat)!="",]

#### running statistical analysis and estimation of individual variances
statOut <- statWrapper(dat, NumReps, NumCond, isPaired, T)

dat <- statOut$dat
Sds <- dat[,ncol(dat)]
print(paste("Features:",nrow(dat),"<br/>Missing values:",
            sum(is.na(dat)),"<br/>Median standard deviations:",
            round(median(Sds,na.rm=T),digits=3)))

## Write output into file 
write.csv(statOut$statFileOut,paste("",Experiment,"statFileOut.csv",sep=""))

```

## Estimation of cluster number

There is no simple way to find an optimal number of clusters in a data set. For obtaining this number, we run the clustering for different cluster numbers and evaluated them via so-called validity indices, which provide information about suitable cluster numbers.


```{r}

#### Estimate number of clusters with maxClust as maximum number clusters to test for
clustNumOut <- estimClustNum(dat, maxClust, cores)

#### Use estimate cluster number or use own
if (PreSetNumClustVSClust == 0)
  PreSetNumClustVSClust <- clustNumOut$numclust
if (PreSetNumClustStand == 0)
  PreSetNumClustStand <- clustNumOut$numclust


```

## Clustering

Now we run the clustering again with the optimal parameters

First, we run the variance-sensitive method

``` {r}


#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, NULL, VSClust=T, cores)
Bestcl <- ClustOut$Bestcl
VSClust_cl <- Bestcl
#ClustOut$p
## Write clustering results (VSClust)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
                     Bestcl$membership), paste(Experiment, "FCMVarMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMVarMResultsCentroids", Sys.Date(), ".csv", sep=""))


```

For comparison, this is the clustering using standard fuzzy c-means of the means over the replicates.

``` {r}



ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
Bestcl <- ClustOut$Bestcl
## Write clustering results (standard fcm)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
                     Bestcl$membership), paste(Experiment, "FCMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))


```

### Biological interpretation

We now will look for the KEGG pathways that are found to be enriched in each of the clusters

``` {r}
## Vector mapping protein names to the same proteins accession names
protnames <- rownames(VSClust_cl$membership)
names(protnames) <- protnames

enriched <- runFuncEnrich(VSClust_cl, dat, protnames, "UNIPROT_ACCESSION", "KEGG_PATHWAY")
x <- enriched$fullFuncs
y <- enriched$redFuncs
BHI <- enriched$BHI
dotplot(y,title=paste("BHI:",round(BHI,digits=3)),showCategory=20,font.size=10)

```
