axis(2)
}
}
if (!(sum(clusterindex == j) == 0)) {
for (jj in 1:(length(colorseq) - 1)) {
tmpcol <- (tmpmem >= colorseq[jj] & tmpmem <=
colorseq[jj + 1])
print(tmpcol)
if (sum(tmpcol, na.rm=T) > 0) {
tmpind <- which(tmpcol)
for (k in 1:length(tmpind)) {
lines(tmp[tmpind[k], ], col = colo[jj])
}
}
}
}
}
if (!is.na(filename))   dev.off()
}
rowMaxs(Bestcl$membership)
## Plot results
mfuzz.plot(tData,cl=Bestcl,mfrow=c(round(sqrt(NClust)),ceiling(sqrt(NClust))),min.mem=0.5,colo="fancy")
which(c(T,F,T,T,NA))
NClust
dim(Bestcl$membership)
mfuzz.plot <- function (dat, cl, mfrow = c(1, 1), colo, min.mem = 0, time.labels,
filename=NA,xlab="Time",ylab="Expression changes")
{
clusterindex <- cl[[3]]
memship <- cl[[4]]
memship[memship < min.mem] <- -1
colorindex <- integer(dim(dat)[[1]])
if (missing(colo)) {
colo <- c("#FF8F00", "#FFA700", "#FFBF00", "#FFD700",
"#FFEF00", "#F7FF00", "#DFFF00", "#C7FF00", "#AFFF00",
"#97FF00", "#80FF00", "#68FF00", "#50FF00", "#38FF00",
"#20FF00", "#08FF00", "#00FF10", "#00FF28", "#00FF40",
"#00FF58", "#00FF70", "#00FF87", "#00FF9F", "#00FFB7",
"#00FFCF", "#00FFE7", "#00FFFF", "#00E7FF", "#00CFFF",
"#00B7FF", "#009FFF", "#0087FF", "#0070FF", "#0058FF",
"#0040FF", "#0028FF", "#0010FF", "#0800FF", "#2000FF",
"#3800FF", "#5000FF", "#6800FF", "#8000FF", "#9700FF",
"#AF00FF", "#C700FF", "#DF00FF", "#F700FF", "#FF00EF",
"#FF00D7", "#FF00BF", "#FF00A7", "#FF008F", "#FF0078",
"#FF0060", "#FF0048", "#FF0030", "#FF0018")
}
colorseq <- seq(0, 1, length = length(colo))
for (j in 1:max(clusterindex)) {
tmp <- dat[clusterindex == j, ]
tmpmem <- memship[clusterindex == j, j]
if (((j - 1)%%(mfrow[1] * mfrow[2])) == 0) {
if (!is.na(filename)) {
pdf(filename, height=3*mfrow[1],width=3*mfrow[2])
}
par(mfrow = mfrow, cex=0.5)
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
else {
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
if (!(sum(clusterindex == j) == 0)) {
for (jj in 1:(length(colorseq) - 1)) {
tmpcol <- (tmpmem >= colorseq[jj] & tmpmem <=
colorseq[jj + 1])
print(colorseq)
if (sum(tmpcol, na.rm=T) > 0) {
tmpind <- which(tmpcol)
for (k in 1:length(tmpind)) {
lines(tmp[tmpind[k], ], col = colo[jj])
}
}
}
}
}
if (!is.na(filename))   dev.off()
}
## Plot results
mfuzz.plot(tData,cl=Bestcl,mfrow=c(round(sqrt(NClust)),ceiling(sqrt(NClust))),min.mem=0.5,colo="fancy")
mfuzz.plot <- function (dat, cl, mfrow = c(1, 1), colo, min.mem = 0, time.labels,
filename=NA,xlab="Time",ylab="Expression changes")
{
clusterindex <- cl[[3]]
memship <- cl[[4]]
memship[memship < min.mem] <- -1
colorindex <- integer(dim(dat)[[1]])
if (missing(colo)) {
colo <- c("#FF8F00", "#FFA700", "#FFBF00", "#FFD700",
"#FFEF00", "#F7FF00", "#DFFF00", "#C7FF00", "#AFFF00",
"#97FF00", "#80FF00", "#68FF00", "#50FF00", "#38FF00",
"#20FF00", "#08FF00", "#00FF10", "#00FF28", "#00FF40",
"#00FF58", "#00FF70", "#00FF87", "#00FF9F", "#00FFB7",
"#00FFCF", "#00FFE7", "#00FFFF", "#00E7FF", "#00CFFF",
"#00B7FF", "#009FFF", "#0087FF", "#0070FF", "#0058FF",
"#0040FF", "#0028FF", "#0010FF", "#0800FF", "#2000FF",
"#3800FF", "#5000FF", "#6800FF", "#8000FF", "#9700FF",
"#AF00FF", "#C700FF", "#DF00FF", "#F700FF", "#FF00EF",
"#FF00D7", "#FF00BF", "#FF00A7", "#FF008F", "#FF0078",
"#FF0060", "#FF0048", "#FF0030", "#FF0018")
}
colorseq <- seq(0, 1, length = length(colo))
print(colorseq)
for (j in 1:max(clusterindex)) {
tmp <- dat[clusterindex == j, ]
tmpmem <- memship[clusterindex == j, j]
if (((j - 1)%%(mfrow[1] * mfrow[2])) == 0) {
if (!is.na(filename)) {
pdf(filename, height=3*mfrow[1],width=3*mfrow[2])
}
par(mfrow = mfrow, cex=0.5)
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
else {
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
if (!(sum(clusterindex == j) == 0)) {
for (jj in 1:(length(colorseq) - 1)) {
tmpcol <- (tmpmem >= colorseq[jj] & tmpmem <=
colorseq[jj + 1])
if (sum(tmpcol, na.rm=T) > 0) {
tmpind <- which(tmpcol)
for (k in 1:length(tmpind)) {
lines(tmp[tmpind[k], ], col = colo[jj])
}
}
}
}
}
if (!is.na(filename))   dev.off()
}
## Plot results
mfuzz.plot(tData,cl=Bestcl,mfrow=c(round(sqrt(NClust)),ceiling(sqrt(NClust))),min.mem=0.5,colo="fancy")
library(Mfuzz)
Mfuzz::mfuzz.plot2
mfuzz.plot <- function (dat, cl, mfrow = c(1, 1), colo, min.mem = 0, time.labels,
filename=NA,xlab="Time",ylab="Expression changes")
{
clusterindex <- cl[[3]]
memship <- cl[[4]]
memship[memship < min.mem] <- -1
colorindex <- integer(dim(dat)[[1]])
if (missing(colo)) {
colo <- c("#FF8F00", "#FFA700", "#FFBF00", "#FFD700",
"#FFEF00", "#F7FF00", "#DFFF00", "#C7FF00", "#AFFF00",
"#97FF00", "#80FF00", "#68FF00", "#50FF00", "#38FF00",
"#20FF00", "#08FF00", "#00FF10", "#00FF28", "#00FF40",
"#00FF58", "#00FF70", "#00FF87", "#00FF9F", "#00FFB7",
"#00FFCF", "#00FFE7", "#00FFFF", "#00E7FF", "#00CFFF",
"#00B7FF", "#009FFF", "#0087FF", "#0070FF", "#0058FF",
"#0040FF", "#0028FF", "#0010FF", "#0800FF", "#2000FF",
"#3800FF", "#5000FF", "#6800FF", "#8000FF", "#9700FF",
"#AF00FF", "#C700FF", "#DF00FF", "#F700FF", "#FF00EF",
"#FF00D7", "#FF00BF", "#FF00A7", "#FF008F", "#FF0078",
"#FF0060", "#FF0048", "#FF0030", "#FF0018")
}    else {
if (colo == "fancy") {
fancy.blue <- c(c(255:0), rep(0, length(c(255:0))),
rep(0, length(c(255:150))))
fancy.green <- c(c(0:255), c(255:0), rep(0, length(c(255:150))))
fancy.red <- c(c(0:255), rep(255, length(c(255:0))),
c(255:150))
colo <- rgb(b = fancy.blue/255, g = fancy.green/255,
r = fancy.red/255)
}
}
colorseq <- seq(0, 1, length = length(colo))
print(colorseq)
for (j in 1:max(clusterindex)) {
tmp <- dat[clusterindex == j, ]
tmpmem <- memship[clusterindex == j, j]
if (((j - 1)%%(mfrow[1] * mfrow[2])) == 0) {
if (!is.na(filename)) {
pdf(filename, height=3*mfrow[1],width=3*mfrow[2])
}
par(mfrow = mfrow, cex=0.5)
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
else {
if (sum(clusterindex == j) == 0) {
ymin <- -1
ymax <- +1
}
else {
ymin <- min(tmp)
ymax <- max(tmp)
}
plot.default(x = NA, xlim = c(1, dim(dat)[[2]]),
ylim = c(ymin, ymax), xlab = xlab, ylab = ylab,
main = paste("Cluster", j), axes = FALSE)
if (missing(time.labels)) {
axis(1, 1:dim(dat)[[2]], c(1:dim(dat)[[2]]))
axis(2)
}
else {
axis(1, 1:dim(dat)[[2]], time.labels)
axis(2)
}
}
if (!(sum(clusterindex == j) == 0)) {
for (jj in 1:(length(colorseq) - 1)) {
tmpcol <- (tmpmem >= colorseq[jj] & tmpmem <=
colorseq[jj + 1])
if (sum(tmpcol, na.rm=T) > 0) {
tmpind <- which(tmpcol)
for (k in 1:length(tmpind)) {
lines(tmp[tmpind[k], ], col = colo[jj])
}
}
}
}
}
if (!is.na(filename))   dev.off()
}
## Plot results
mfuzz.plot(tData,cl=Bestcl,mfrow=c(round(sqrt(NClust)),ceiling(sqrt(NClust))),min.mem=0.5,colo="fancy")
library(vsclust)
knitr::opts_chunk$set(echo = TRUE)
library(vsclust)
require(yaml)
require(shiny)
require(clusterProfiler)
#### Input parameters, only read when now parameter file was provided #####
# All principal parameters for running VSClust can be defined as in the shiny app at computproteomics.bmb.sdu.dk/Apps/VSClust
Experiment <- "ProtExample" ## name of study
NumReps <- 3###886 ## Number of replicates per
NumCond <- 4###12 ## Number of different experimental conditions (e.g. time points)
isPaired <- F ## Paired or unpaired statistical tests
cores <- 4#4 # Number of cores to use ## 1 is for windows
PreSetNumClustVSClust <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
PreSetNumClustStand <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
maxClust <- 10 ## max. number of clusters when estimating the number of clusters
dat <- read.csv(system.file("extdata/ProtExample.csv",package="vsclust"),row.names=1,header=T)
dat <- dat[rownames(dat)!="",]
#### running statistical analysis and estimation of individual variances
statOut <- statWrapper(dat, NumReps, NumCond, isPaired, T)
dat <- statOut$dat
Sds <- dat[,ncol(dat)]
print(paste("Features:",nrow(dat),"<br/>Missing values:",
sum(is.na(dat)),"<br/>Median standard deviations:",
round(median(Sds,na.rm=T),digits=3)))
## Write output into file
write.csv(statOut$statFileOut,paste("",Experiment,"statFileOut.csv",sep=""))
#### Estimate number of clusters with maxClust as maximum number clusters to test for
clustNumOut <- estimClustNum(dat, maxClust, cores)
#### Use estimate cluster number or use own
if (PreSetNumClustVSClust == 0)
PreSetNumClustVSClust <- clustNumOut$numclust
if (PreSetNumClustStand == 0)
PreSetNumClustStand <- clustNumOut$numclust
## Create pdf-figure of validation indices "minimum centroid distance" and "Xie-Beni index"
#pdf(paste(Experiment,"EstimatedClustNumber.pdf", sep=""),height=6,width=15)
print(clustNumOut$p)
#dev.off()
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, proteins, VSClust=T, cores)
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, proteins, VSClust=T, cores)
proteins
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, NULL, VSClust=T, cores)
roxygen2::roxygenize(clean=T)
library(vsclust)
runClustWrapper
knitr::opts_chunk$set(echo = TRUE)
library(vsclust)
require(yaml)
require(shiny)
require(clusterProfiler)
#### Input parameters, only read when now parameter file was provided #####
# All principal parameters for running VSClust can be defined as in the shiny app at computproteomics.bmb.sdu.dk/Apps/VSClust
Experiment <- "ProtExample" ## name of study
NumReps <- 3###886 ## Number of replicates per
NumCond <- 4###12 ## Number of different experimental conditions (e.g. time points)
isPaired <- F ## Paired or unpaired statistical tests
cores <- 4#4 # Number of cores to use ## 1 is for windows
PreSetNumClustVSClust <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
PreSetNumClustStand <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
maxClust <- 10 ## max. number of clusters when estimating the number of clusters
dat <- read.csv(system.file("extdata/ProtExample.csv",package="vsclust"),row.names=1,header=T)
dat <- dat[rownames(dat)!="",]
#### running statistical analysis and estimation of individual variances
statOut <- statWrapper(dat, NumReps, NumCond, isPaired, T)
dat <- statOut$dat
Sds <- dat[,ncol(dat)]
print(paste("Features:",nrow(dat),"<br/>Missing values:",
sum(is.na(dat)),"<br/>Median standard deviations:",
round(median(Sds,na.rm=T),digits=3)))
## Write output into file
write.csv(statOut$statFileOut,paste("",Experiment,"statFileOut.csv",sep=""))
#### Estimate number of clusters with maxClust as maximum number clusters to test for
clustNumOut <- estimClustNum(dat, maxClust, cores)
#### Use estimate cluster number or use own
if (PreSetNumClustVSClust == 0)
PreSetNumClustVSClust <- clustNumOut$numclust
if (PreSetNumClustStand == 0)
PreSetNumClustStand <- clustNumOut$numclust
## Create pdf-figure of validation indices "minimum centroid distance" and "Xie-Beni index"
#pdf(paste(Experiment,"EstimatedClustNumber.pdf", sep=""),height=6,width=15)
print(clustNumOut$p)
#dev.off()
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, NULL, VSClust=T, cores)
Bestcl <- ClustOut$Bestcl
ClustOut$p
## Write clustering results (VSClust)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMVarMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMVarMResultsCentroids", Sys.Date(), ".csv", sep=""))
## Write pdf-figure of clusters
#pdf(paste(Experiment,"FCMVarMResults", Sys.Date(), ".pdf", sep=""),height=5*round(sqrt(PreSetNumClustVSClust)),width=5*ceiling(sqrt(PreSetNumClustVSClust)))
print(ClustOut$p)
#dev.off()
#  print(ClustOut$ClustInd)
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, proteins, VSClust=F, cores)
proteins
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
Bestcl <- ClustOut$Bestcl
ClustOut$p
## Write clustering results (standard fcm)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))
## Write pdf-figure of clusters
#pdf(paste(Experiment,"FCMResults", Sys.Date(), ".pdf", sep=""),height=5*round(sqrt(PreSetNumClustStand)),width=5*ceiling(sqrt(PreSetNumClustStand)))
print(ClustOut$p)
ClustOut$p
## Write pdf-figure of clusters
#pdf(paste(Experiment,"FCMVarMResults", Sys.Date(), ".pdf", sep=""),height=5*round(sqrt(PreSetNumClustVSClust)),width=5*ceiling(sqrt(PreSetNumClustVSClust)))
ClustOut$p
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
Bestcl <- ClustOut$Bestcl
ClustOut$p
## Write clustering results (standard fcm)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))
## Write pdf-figure of clusters
#pdf(paste(Experiment,"FCMResults", Sys.Date(), ".pdf", sep=""),height=5*round(sqrt(PreSetNumClustStand)),width=5*ceiling(sqrt(PreSetNumClustStand)))
print(Clus
Out$p)
#dev.off()
print(ClustOut$ClustInd)
knitr::opts_chunk$set(echo = TRUE)
library(vsclust)
require(yaml)
require(shiny)
require(clusterProfiler)
#### Input parameters, only read when now parameter file was provided #####
# All principal parameters for running VSClust can be defined as in the shiny app at computproteomics.bmb.sdu.dk/Apps/VSClust
Experiment <- "ProtExample" ## name of study
NumReps <- 3###886 ## Number of replicates per
NumCond <- 4###12 ## Number of different experimental conditions (e.g. time points)
isPaired <- F ## Paired or unpaired statistical tests
cores <- 4#4 # Number of cores to use ## 1 is for windows
PreSetNumClustVSClust <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
PreSetNumClustStand <- 0 # If 0, then automatically take the one from Minimum Centroid Distance
maxClust <- 10 ## max. number of clusters when estimating the number of clusters
dat <- read.csv(system.file("extdata/ProtExample.csv",package="vsclust"),row.names=1,header=T)
dat <- dat[rownames(dat)!="",]
#### running statistical analysis and estimation of individual variances
statOut <- statWrapper(dat, NumReps, NumCond, isPaired, T)
dat <- statOut$dat
Sds <- dat[,ncol(dat)]
print(paste("Features:",nrow(dat),"<br/>Missing values:",
sum(is.na(dat)),"<br/>Median standard deviations:",
round(median(Sds,na.rm=T),digits=3)))
## Write output into file
write.csv(statOut$statFileOut,paste("",Experiment,"statFileOut.csv",sep=""))
#### Estimate number of clusters with maxClust as maximum number clusters to test for
clustNumOut <- estimClustNum(dat, maxClust, cores)
#### Use estimate cluster number or use own
if (PreSetNumClustVSClust == 0)
PreSetNumClustVSClust <- clustNumOut$numclust
if (PreSetNumClustStand == 0)
PreSetNumClustStand <- clustNumOut$numclust
## Create pdf-figure of validation indices "minimum centroid distance" and "Xie-Beni index"
#pdf(paste(Experiment,"EstimatedClustNumber.pdf", sep=""),height=6,width=15)
print(clustNumOut$p)
#dev.off()
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, NULL, VSClust=T, cores)
Bestcl <- ClustOut$Bestcl
ClustOut$p
## Write clustering results (VSClust)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMVarMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMVarMResultsCentroids", Sys.Date(), ".csv", sep=""))
ClustOut$p
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
Bestcl <- ClustOut$Bestcl
ClustOut$p
## Write clustering results (standard fcm)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))
ClustOut$p
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
ClustOut <- runClustWrapper(dat, PreSetNumClustStand, NULL, VSClust=F, cores)
Bestcl <- ClustOut$Bestcl
## Write clustering results (standard fcm)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMResultsCentroids", Sys.Date(), ".csv", sep=""))
#### Run clustering (VSClust and standard fcm clustering
ClustOut <- runClustWrapper(dat, PreSetNumClustVSClust, NULL, VSClust=T, cores)
Bestcl <- ClustOut$Bestcl
#ClustOut$p
## Write clustering results (VSClust)
write.csv(data.frame(cluster=Bestcl$cluster,ClustOut$outFileClust,isClusterMember=rowMaxs(Bestcl$membership)>0.5,maxMembership=rowMaxs(Bestcl$membership),
Bestcl$membership), paste(Experiment, "FCMVarMResults", Sys.Date(), ".csv", sep=""))
## Write coordinates of cluster centroids
write.csv(Bestcl$centers, paste(Experiment,"FCMVarMResultsCentroids", Sys.Date(), ".csv", sep=""))
shiny::runApp('inst/shiny')
